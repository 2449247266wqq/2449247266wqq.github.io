<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java内部类学习</title>
    <url>/2019/11/11/Java%E5%86%85%E9%83%A8%E7%B1%BB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><center>内部类</center></h1><p>可以将一个类的定义放在另一个类得定义内部，这就是内部类。</p>
<h3 id="一、创建内部类"><a href="#一、创建内部类" class="headerlink" title="一、创建内部类"></a>一、创建内部类</h3><p>创建内部类的方式:把类的定义置于外围类的里面。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        B(String b2)</span><br><span class="line">        &#123;</span><br><span class="line">            b=b2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">String <span class="title">readb2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> A();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">B1</span><span class="params">(String b3)</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> B(b3);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">C</span><span class="params">(String test)</span></span>&#123;</span><br><span class="line">        A a=A1();</span><br><span class="line">        B b4=B1(test);</span><br><span class="line">        System.out.println(b4.readb2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体指明这个对象的类型:外部类名.内部类名。</p>
<h3 id="二、链接到外部类"><a href="#二、链接到外部类" class="headerlink" title="二、链接到外部类"></a>二、链接到外部类</h3><p>当生成一个内部类对象时，这个对象与制造它的外围对象有了一种联系，它可以访问其外围对象的所有成员。内部类也还拥有外围类的所有元素访问权。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkToExternalClass;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squence</span></span></span><br><span class="line"><span class="class"></span>&#123;	<span class="keyword">private</span> Object[] items;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Squence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;items = <span class="keyword">new</span> Object[size];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(next &lt; items.length)</span><br><span class="line">			items[next++] =x ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SquenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i ==items.length;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> items[i];&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span>(i&lt;items.length) i++;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SquenceSelector();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Squence sequence= <span class="keyword">new</span> Squence(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			sequence.add(Integer.toString(i));</span><br><span class="line">		Selector selector = sequence.selector();</span><br><span class="line">		<span class="keyword">while</span>(!selector.end()) &#123;</span><br><span class="line">			System.out.print(selector.current()+<span class="string">" "</span>);</span><br><span class="line">			selector.next();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用到了迭代器的设计模式，迭代器:提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。<br>内部类自动拥有对其外围类所有成员的访问权。</p>
<h3 id="三、使用-this和-new"><a href="#三、使用-this和-new" class="headerlink" title="三、使用.this和.new"></a>三、使用.this和.new</h3><p>如果需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟.this,这样产生的引用自动的具有正确的类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkToExternalClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usethis</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"F()"</span>);&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Usethis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Usethis.<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Usethis d = <span class="keyword">new</span> Usethis();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时候可能想告知某些其他对象，去创建其某个内部类的对象，要实现就必须在new表达式中提供对其他外部类对象的引用，就使用.new。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkToExternalClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseNew</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		UseNew d = <span class="keyword">new</span> UseNew();</span><br><span class="line">		UseNew.Inner c=d.new Inner();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想要直接创建内部类的对象，不能直接使用<strong>d.new UseNew.Inner()</strong>,必须使用外部类的对象来创建内部类的对象。<br>在拥有外部类对象之前不可能创建内部类对象，但是如果是嵌套类（静态内部类），就不需要对外部类的引用。</p>
<h3 id="四、内部类和向上转型"><a href="#四、内部类和向上转型" class="headerlink" title="四、内部类和向上转型"></a>四、内部类和向上转型</h3><p>将内部类向上转型为其基类，尤其是转型为一个接口时，就可以使用内部类，从实现某个接口的对象，得到对此接口的引用，与向上转型为i这个对象的基类，实际上是一样的。因为此内部类——某个接口的实现——能够完全不可见，并且不可用，所以得到的只是指向基类或接口的引用，能很方便的隐藏实现细节。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> InnerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> InnerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> InnerClass;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p4</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">11</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestinations</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String label;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">PDestinations</span><span class="params">(String whereTo)</span></span></span><br><span class="line"><span class="function">		</span>&#123;label=whereTo;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PDestinations(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		p4 p = <span class="keyword">new</span> p4();</span><br><span class="line">		Contents c = p.contents();</span><br><span class="line">		Destination d = p.destination(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，内部类PContents是private，出来p4没有人能访问它。PDestination是protected的，只一抔p4及其子类，还要同包里的类能访问。客户端程序员不能访问这些成员，甚至不能向下转型成private内部类。private内部类给设计者提供了一种途径，通过这种方法可以阻止任何依赖于类型的编码，而且隐藏了实现的细节。</p>
<h3 id="五、在方法和作用域内的内部类"><a href="#五、在方法和作用域内的内部类" class="headerlink" title="五、在方法和作用域内的内部类"></a>五、在方法和作用域内的内部类</h3><p>后面将展示以下类:<br>一个定义在方法中的类。<br>一个定义在作用域里面的类，此作用域在方法的内部。<br>一个实现了接口的你，匿名类。<br>一个匿名类，它扩展了有非默认构造器的类。<br>一个匿名类，执行字段初始化。<br>一个匿名类，它通过实例初始化实现构造器，匿名类补可能有构造器。<br>在方法的作用域创建完整的类:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p5</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">			<span class="keyword">private</span> String label;</span><br><span class="line">			<span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">				label=whereTo;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PDestination是destination方法的一部分，不是p5的一部分，所以destination之外不能访问PDestination。<br>可以在同一个子目录下的任意类中对某个内部类使用类标识符PDestination，并不会有命名冲突。<br>在任意作用域内嵌入一个类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该类被嵌入到if的作用域里面，并不是说该类的创建有条件，它与其它别的类一起编译过了，然而，在这个作用域之外，它是不可用的。</p>
<h3 id="六、匿名内部类"><a href="#六、匿名内部类" class="headerlink" title="六、匿名内部类"></a>六、匿名内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> InnerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p7</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">11</span>;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		p7 p = <span class="keyword">new</span> p7();</span><br><span class="line">		Contents c = p.contents();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>contents方法将返回值的生成与表示这个返回值的类的定义结合在一起。它是匿名的，没有名字。<br>上述匿名类的语法是下述的简写<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">11</span>;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> MyCountents();&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果基类需要一个有参数的构造器:只需要简单地传递合适的参数给基类的构造器即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p8</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> wrapping(x)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.value()*<span class="number">47</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;i=x;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value &#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此Wrapping中拥有一个要求传递参数的构造器。<br>匿名类的分号并不是标记此内部类的结束，标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。<br>在匿名类内部定义字段时，还能对其执行初始化操作。<br>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，编译器会要求其参数引用是final的。<br>匿名类中不可能有命名构造器，但通过实例初始化，就能达到这种效果。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> InnerClass;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Base constructor,i="</span>+i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Base(i) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Inside instance initializer"</span>);</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"In anonymous f()"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConstructor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Base base = getBase(<span class="number">47</span>);</span><br><span class="line">		base.f();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此例中，不要求变量i一定是final。因为i被传递给匿名类的基类的构造器，并不会在匿名类内部被直接使用。<br>下面是带实例初始化的p形式。请注意destination的参数必须是final的,因为他们在匿名类的内部使用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest,<span class="keyword">final</span> <span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Destination()&#123;</span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">			&#123;</span><br><span class="line">				cost=Math.round(price);</span><br><span class="line">				<span class="keyword">if</span>(cost&gt;<span class="number">100</span>)</span><br><span class="line">				System.out.println(<span class="string">"Over buudget!"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">private</span> String label = dest;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p p1 = <span class="keyword">new</span> p();</span><br><span class="line">		Destination d = p.destination(<span class="string">"www"</span>,<span class="number">11.123F</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="再次看工厂方法"><a href="#再次看工厂方法" class="headerlink" title="再次看工厂方法"></a>再次看工厂方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">	<span class="function">Server <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Implementation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Imp1 m1"</span>)&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Imp1 m2"</span>)&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory factory= <span class="keyword">new</span> ServiceFactory()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、嵌套类"><a href="#七、嵌套类" class="headerlink" title="七、嵌套类"></a>七、嵌套类</h3><p>如果不需要内部对象与其外围类对象之间有联系，可以将内部类声明为static。称之为嵌套类。嵌套类意味着:<br>1.要创建嵌套类对象，并不需要其外围类的对象。<br>2.不能从嵌套类的对象中访问非静态的外围类对象。<br>普通内部类的字段与方法，只能放在类的外部层次上普通内部类不能有static数据和字段，也不能包含嵌套类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> NestedClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> InnerClass.Contents;</span><br><span class="line"><span class="keyword">import</span> InnerClass.Destination;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">11</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String label;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">			label=whereTo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">int</span> x =<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AntherLevel</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">static</span> <span class="keyword">int</span> x= <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Contents c = contents();</span><br><span class="line">		Destination d = destination(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main中，没有必要创建外围函数的对象，而是选取static成员的普通语法来调用方法，这个方法返回对Contents和Destination的引用。在一个普通的内部类中，通过一个特殊的this引用可以链接到外围类对象。嵌套类就没有这个特殊的this引用。</p>
<h4 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h4><p>正常情况下，不能在接口内部放置任何代码，但是嵌套类可以作为接口的一部分。因为类是static的，只是将嵌套类置于接口的命名空间内，并不违反接口规则。甚至可以在内部类实现其外围接口。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">			<span class="keyword">new</span> Test().howdy();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>如果想创建某别公共代码，使得他们可以被某个接口的所有不同实现所共有，可以使用嵌套类。如果每个类都写一个main()方法，用来测试这个类。这样做有一个缺点，那就是必须带着那些已编译过的额外代码。现在，也可以使用嵌套类来放置测试代码。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBed</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">			TestBed t = <span class="keyword">new</span> TestBed();</span><br><span class="line">			t.f();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里生成一个独立的类，可以使用这个类来做测试。</p>
<h4 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h4><p>一个类被嵌套多少层并不重要，他能透明的访问所有它所嵌入的外围类的所有成员。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">				g();</span><br><span class="line">				f();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuttiNestingAccess</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">			MNA mna = <span class="keyword">new</span> MNA();</span><br><span class="line">			MNA.A mnaa = mna.new A();</span><br><span class="line">			MNA.A.B mnaab = mnaa.new B();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="八、为什么需要内部类"><a href="#八、为什么需要内部类" class="headerlink" title="八、为什么需要内部类"></a>八、为什么需要内部类</h3><p>内部类最吸引人的原因就是:每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function">B <span class="title">makeB</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> B()&#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个实现方法都没有任何问题，必须根据实际情况做出选择。但是如果拥有的是抽象的类或者具体的类，不是接口，就只能使用内部类才能实现多重继承。<br>使用内部类还可以获得其他一些特性:<br>1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。<br>2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。<br>3.创建内部类对象的时刻并不依赖于外围类对象的创建。<br>4.内部类并没有令人迷惑的”is-a”关系，它就是一个独立的实体。</p>
<h4 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h4><p>闭包（closure）是一个可以调用的对象，它记录了一些信息，这些信息来自与创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，再此作用域内，内部类有权操作所有的成员，包括private。<br>回调（callback）。通过 回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻用初始的对象。<br>通过内部类提供闭包的功能是优良的解决方案。</p>
<h4 id="内部类与控制框架"><a href="#内部类与控制框架" class="headerlink" title="内部类与控制框架"></a>内部类与控制框架</h4><p>应用程序框架就是被设计用以解决某类特定问题得一个类或者一组类。控制框架是一类特殊得应用程序框架，它用来解决响应事件得需求。主要用来响应事件的系统被称作事件驱动系统。<br>一个简单的<a href="https://github.com/2449247266wqq/A-simple-java.git" target="_blank" rel="noopener">例子</a>(请点链接)</p>
<h3 id="九、内部类的继承"><a href="#九、内部类的继承" class="headerlink" title="九、内部类的继承"></a>九、内部类的继承</h3><p>因为内部类的构造器必须链接到指向其外围类对象的引用，继承内部类会有些复杂。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">	InheritInner(WithInner wi)&#123;</span><br><span class="line">		wi.<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">		InheritInner i = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="十、内部类可以被覆盖吗"><a href="#十、内部类可以被覆盖吗" class="headerlink" title="十、内部类可以被覆盖吗"></a>十、内部类可以被覆盖吗</h3><p>如果创建了一个 内部类，然后继承其外围类并重新定义此内部类，会发生什么。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Yolk y;</span><br><span class="line">	<span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">			print(<span class="string">"Egg.Yolk"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Egg&#123;</span><br><span class="line">		print(<span class="string">"New Egg"</span>);</span><br><span class="line">		y = <span class="keyword">new</span> Yolk();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">			print(<span class="string">"BigEgg.Yolk()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> BigEgg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果输出如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">New <span class="title">Egg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Egg.<span class="title">yolk</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>内部类的构造器并没有被覆盖，内部类是完全独立的实体，各自在自己的命名空间。也可以明确地继承某个内部类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">			print(<span class="string">"Egg2.Yolk()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			print(<span class="string">"Egg2.Yolk.f()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Egg2</span><span class="params">()</span></span>&#123;print(<span class="string">"New Egg2()"</span>);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span></span>&#123;y=yy;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;y.f();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">			print(<span class="string">"BigEgg2.Yolk()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			print(<span class="string">"BigEgg2.Yolk.f()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		insertYolk(<span class="keyword">new</span> Yolk());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Egg2 e2 = <span class="keyword">new</span> BigEgg2();</span><br><span class="line">		e2.g();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Egg2.Yolk()</span><br><span class="line"><span class="function">New <span class="title">Egg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Egg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.Yolk.<span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="十一、局部内部类"><a href="#十一、局部内部类" class="headerlink" title="十一、局部内部类"></a>十一、局部内部类</h3><p>局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，以及此外围类的所有成员。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> <span class="keyword">implements</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="title">LocalCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">				print(<span class="string">"LocalCounter()"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">				printnb(name);</span><br><span class="line">				<span class="keyword">return</span> counter++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Counter()&#123;</span><br><span class="line">				print(<span class="string">"LocalCounter()"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">				printnb(name);</span><br><span class="line">				<span class="keyword">return</span> counter++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">		Counter</span><br><span class="line">			c1 = lic.getCounter(<span class="string">"Local inner"</span>),</span><br><span class="line">			c2 = lic.getCounter(<span class="string">"Anonymous inner"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">			print(c1.next());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">			print(c2.next());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalCounter()</span><br><span class="line">Counter()</span><br><span class="line">Local inner <span class="number">0</span></span><br><span class="line">Local inner <span class="number">1</span></span><br><span class="line">Local inner <span class="number">2</span></span><br><span class="line">Local inner <span class="number">3</span></span><br><span class="line">Local inner <span class="number">4</span></span><br><span class="line">Anonymous inner <span class="number">5</span></span><br><span class="line">Anonymous inner <span class="number">6</span></span><br><span class="line">Anonymous inner <span class="number">7</span></span><br><span class="line">Anonymous inner <span class="number">8</span></span><br><span class="line">Anonymous inner <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="十二、内部类标识符"><a href="#十二、内部类标识符" class="headerlink" title="十二、内部类标识符"></a>十二、内部类标识符</h3><p>每一个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个“mela-class”，叫做Class对象），内部类也必须生成一个相同的文件。规则是:外围类的名字加上“\$”,再加上内部类的名字比如上面的例子<br>Counter.class<br>LocalInnerClass\$1.class<br>LocalInnerClass\$1LocalCounter.class<br>LocalInnerClass.class<br>如果是匿名内部类，编译器就简单地产生一个数字作为其标识符，如果内部类是嵌套在别的内部类之中，只需要直接将它们的名字加在其外围类标识符与“\$”的后面。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此文章用于记录本人学习Java中的学习笔记，用的教材是Java编程思想第四版,如有不足请多指教。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口学习</title>
    <url>/2019/11/08/Java%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a><center>接口</center></h1><h3 id="一、抽象类与抽象方法"><a href="#一、抽象类与抽象方法" class="headerlink" title="一、抽象类与抽象方法"></a>一、抽象类与抽象方法</h3><p>抽象方法声明的语法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果一个类包含抽象方法，它就必须限定为抽象类。<br>抽象类不能产生对象。<br>如果继承一个抽象类，就必须为基类所有方法提供方法定义，否则该类也为抽象类。</p>
<h3 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h3><p>abstract允许人们在类中创建一个或多个没有任何定义的方法——提供接口部分，实现只能通过继承者来实现。interface产生一个完全抽象的类，没有提供任何具体实现有方法名，参数列表以及返回类型，但是无任何方法体，只是提供形式，无任何具体实现。<br>接口定义方法:将interface代替class。<br>某个类遵循一个接口或一组接口，需要用implements关键字。这个类就变成一个普通的类。接口中的所有方法默认为public。</p>
<h3 id="三、完全解耦"><a href="#三、完全解耦" class="headerlink" title="三、完全解耦"></a>三、完全解耦</h3><p>具体详情请见我的 <a href="https://github.com/2449247266wqq/Java-complete-decoupling" target="_blank" rel="noopener">github java-complete-decouping</a>。</p>
<h3 id="四、Java中的多重继承"><a href="#四、Java中的多重继承" class="headerlink" title="四、Java中的多重继承"></a>四、Java中的多重继承</h3><p>C++中组合多个类的接口的行为被称为多重继承，这样每个类都有一个具体实现，会使问题变得很麻烦。但在Java中，可以做相同的事情，但是只有一个类去具体实现。可以继承与接口组合。可以继承多个接口，并且向上转型为每个接口。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> MultipleInherit;</span><br><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> MultipleInherit;</span><br><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">swin</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> MultipleInherit;</span><br><span class="line"><span class="comment">//定义一个基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"I can fight!"</span>);&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> MultipleInherit;</span><br><span class="line"><span class="comment">//定义一个类，去组合Action基类和CanFight，CanSwin接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Action</span> <span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"I can swim!"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> MultipleInherit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">canfight</span><span class="params">(CanFight a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a.fight();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">canswin</span><span class="params">(CanSwin b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		b.swin();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Action c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		c.fight();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Hero x = <span class="keyword">new</span> Hero();</span><br><span class="line">		canfight(x);</span><br><span class="line">		canswin(x);</span><br><span class="line">		action(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个简单的例子中可以看到继承和接口组合的定义方法，记住，组合时，接口列表必须放在后面，而且可以看到CanFight和Action的fight方法相同，Hero中并没有fight的定义，但是由于Hero继承了Action类，fight方法也就随即继承而来，所以也就可以使用a.fight,就可以创建Hero对象。</p>
<h3 id="五、通过继承来扩展接口"><a href="#五、通过继承来扩展接口" class="headerlink" title="五、通过继承来扩展接口"></a>五、通过继承来扩展接口</h3><p>+通过继承，可以很容易的在接口中添加新的方法声明，还可以提供继承在新接口中组合数个接口。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tom</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tommy</span> <span class="keyword">extends</span> <span class="title">Tom</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Ty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lily</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">l</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TommyTom</span> <span class="keyword">implements</span> <span class="title">Tommy</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">T</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Ty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般情况只可以将extends用于单一类。这里可以用于接口继承。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vam</span> <span class="keyword">extends</span> <span class="title">Tommy</span> ,<span class="title">Lily</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerlyBadVampire</span> <span class="keyword">implements</span> <span class="title">Vam</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">T</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Ty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">l</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中我们可以很清楚的看到接口与接口之间的继承扩展以及实现。</p>
<h4 id="接口组合时的名字冲突。"><a href="#接口组合时的名字冲突。" class="headerlink" title="接口组合时的名字冲突。"></a>接口组合时的名字冲突。</h4><p>在上面的例子中，CanFight和Action有相同的方法，在打算组合的不同籍人口中使用相同方法名回造成代码可读的混乱，应尽量避免。</p>
<h3 id="六、适配接口"><a href="#六、适配接口" class="headerlink" title="六、适配接口"></a>六、适配接口</h3><p>接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AdapterInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomDoubles</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> rand.nextDouble();&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		RandomDoubles rd = <span class="keyword">new</span> RandomDoubles();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i ++)</span><br><span class="line">			System.out.print(rd.next()+<span class="string">"      "</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此我们再次使用了适配器模式，被配适的类可以通过继承和实现Readable接口来创建，我们可以生成既是RandomDoubles又是Readable的类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AdapterInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//继承RandomDoubles类，以及实现Readable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptedRandomDoubles</span> <span class="keyword">extends</span> <span class="title">RandomDoubles</span> <span class="keyword">implements</span> <span class="title">Readable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AdaptedRandomDoubles</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count=count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count--==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		String result =Double.toString(next())+<span class="string">" "</span>;</span><br><span class="line">		cb.append(result);</span><br><span class="line">		<span class="keyword">return</span> result.length();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Scanner s =<span class="keyword">new</span> Scanner (<span class="keyword">new</span> AdaptedRandomDoubles(<span class="number">7</span>));</span><br><span class="line">		<span class="keyword">while</span>(s.hasNextDouble())</span><br><span class="line">			System.out.print(s.nextDouble() + <span class="string">"  "</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="七、接口中的域"><a href="#七、接口中的域" class="headerlink" title="七、接口中的域"></a>七、接口中的域</h3><p>放入接口中的任何域都是static和final的，所以接口可以很便捷的用来创建常量工具，这与Java SE5之前的<strong>enum</strong>(枚举类型)相似。随后，随着Java的发展，你可以使用更加强大的<strong>enum</strong>，使用这种方法也没有必要了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AdapterInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceEnum</span></span></span><br><span class="line"><span class="class"></span>&#123;<span class="keyword">int</span></span><br><span class="line">	ONE = <span class="number">1</span>,TWO=<span class="number">2</span>,THREE=<span class="number">3</span>,</span><br><span class="line">	FOUR=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="八、嵌套接口"><a href="#八、嵌套接口" class="headerlink" title="八、嵌套接口"></a>八、嵌套接口</h3><p>接口可以嵌套在其他接口中<br><a href="https://github.com/2449247266wqq/Java-.git" target="_blank" rel="noopener">代码详情</a></p>
<h3 id="九、接口与工厂"><a href="#九、接口与工厂" class="headerlink" title="九、接口与工厂"></a>九、接口与工厂</h3><p>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模式与直接调用构造器不同，我们再工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，使得我们可以透明的将某个实现替换为另一个实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">	<span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	Implementation1()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"Imp1 m1"</span>);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"Imp1 m2"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	Implementation2()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"Imp2 m1"</span>);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"Imp2 m2"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceComsumer</span><span class="params">(ServiceFactory fact)</span> </span>&#123;</span><br><span class="line">		Service s = fact.getService();</span><br><span class="line">		s.m1();</span><br><span class="line">		s.m2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		serviceComsumer(<span class="keyword">new</span> Implementation1Factory());</span><br><span class="line">		serviceComsumer(<span class="keyword">new</span> Implementation2Factory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Imp1 m1</span><br><span class="line">Imp1 m2</span><br><span class="line">Imp2 m1</span><br><span class="line">Imp1 m2</span><br></pre></td></tr></table></figure></p>
<p>此文章用于记录本人学习Java中的学习笔记，用的教材是Java编程思想第四版,如有不足请多指教。<br><code>`</code></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>一些简单的markdown</title>
    <url>/2019/10/25/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84markdown/</url>
    <content><![CDATA[<h2 id="此文章仅用于自己练习"><a href="#此文章仅用于自己练习" class="headerlink" title="此文章仅用于自己练习"></a>此文章仅用于自己练习</h2><h3 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h3><p><del>nihao</del></p>
<p><em>nihao</em></p>
<p><strong>nihao</strong></p>
<p><a href="https://www.douyu.com" target="_blank" rel="noopener">斗鱼tv</a></p>
<p><img src="http://static.leiphone.com/uploads/new/images/20181015/5bc3dd76191d4.jpg?imageView2/0/w/740/h740" alt="斗鱼"></p>
<p>下标:<br>x<sub>2</sub></p>
<p>上标<br>O<sup>2</sup></p>
<p><abbr title="WuQiqi">wqq</abbr></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p>引用文本</p>
</blockquote>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="减号"><a href="#减号" class="headerlink" title="减号(-)"></a>减号(-)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="星号"><a href="#星号" class="headerlink" title="星号(*)"></a>星号(*)</h4><ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="加号"><a href="#加号" class="headerlink" title="加号(+)"></a>加号(+)</h4><ul>
<li>列表一</li>
<li>列表二<ul>
<li>列表三</li>
</ul>
</li>
<li>列表四</li>
</ul>
<h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul>
<li style="list-style: none"><input type="checkbox" checked> GFM task list1<ul>
<li style="list-style: none"><input type="checkbox"> GFM task list2 </li>
</ul>
</li>
</ul>
<h3 id="绘制表格"><a href="#绘制表格" class="headerlink" title="绘制表格"></a>绘制表格</h3><table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>笔记本</td>
<td style="text-align:right">20000</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">1000</td>
<td style="text-align:center">50</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格  </th>
</tr>
</thead>
<tbody>
<tr>
<td>笔记本</td>
<td>20000 </td>
</tr>
<tr>
<td>手机</td>
<td>1000</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>笔记本</td>
<td>20000</td>
<td>20</td>
</tr>
<tr>
<td>手机</td>
<td>1000</td>
<td>50</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>笔记本</code></td>
<td>20000</td>
<td>20</td>
</tr>
<tr>
<td><em>手机</em></td>
<td><strong>1000</strong></td>
<td>50</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">项目</th>
<th style="text-align:center">价格</th>
<th style="text-align:right">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">笔记本</td>
<td style="text-align:center">20000</td>
<td style="text-align:right">20</td>
</tr>
<tr>
<td style="text-align:left">手机</td>
<td style="text-align:center">1000</td>
<td style="text-align:right">50</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>笔记本</td>
<td style="text-align:right">20000</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">1000</td>
</tr>
</tbody>
</table>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>&copy; &amp;  &uml;<br> &trade; &iexcl; &pound;<br>&amp; &lt; &gt;<br> &yen; &euro; &reg;<br>  &plusmn; &para; &sect;<br>   &brvbar; &macr; &laquo;<br>   &middot;</p>
<h3 id="分页符"><a href="#分页符" class="headerlink" title="分页符"></a>分页符</h3><hr>
<h3 id="emoji表情-smiley"><a href="#emoji表情-smiley" class="headerlink" title="emoji表情 :smiley:"></a>emoji表情 :smiley:</h3><blockquote>
<p>Blockquotes :star:</p>
</blockquote>
<ul>
<li style="list-style: none"><input type="checkbox" checked> :smiley: @mentions, :smiley: #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li style="list-style: none"><input type="checkbox" checked> list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li style="list-style: none"><input type="checkbox" checked> :smiley: this is a complete item :smiley:;</li>
<li style="list-style: none"><input type="checkbox"> this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li>
<li style="list-style: none"><input type="checkbox"> this is an incomplete item :fa-star: :fa-gear:;<ul>
<li style="list-style: none"><input type="checkbox"> :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li style="list-style: none"><input type="checkbox"> :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<p>:smiley:  :star: :fa-star:  :fa-gear:</p>
<h3 id="科学公式"><a href="#科学公式" class="headerlink" title="科学公式"></a>科学公式</h3><p>$$E=mc^2$$<br>$$X&gt;Y$$<br>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p>
<h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>FirstDay</title>
    <url>/2019/10/24/FirstDay/</url>
    <content><![CDATA[<h1 id="FirstDay"><a href="#FirstDay" class="headerlink" title="FirstDay"></a>FirstDay</h1><h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2><h3 id="先学习一点点markdown知识"><a href="#先学习一点点markdown知识" class="headerlink" title="先学习一点点markdown知识"></a>先学习一点点markdown知识</h3><ul>
<li>列表1</li>
<li>列表2<br>  a子列表<br>  b子列表</li>
<li>列表3</li>
</ul>
<hr>
<hr>
<hr>
<p><a href="https://www.douyu.com" target="_blank" rel="noopener">斗鱼直播</a><br><img src="http://static.leiphone.com/uploads/new/images/20181015/5bc3dd76191d4.jpg?imageView2/0/w/740/h740" alt="斗鱼tv"><br><em>斜线</em><br><strong>加粗</strong><br><code>&lt;html&gt;&lt;html&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">            body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125;</span><br><span class="line">            ul&#123;list-style: none;&#125;</span><br><span class="line">            img&#123;border:none;vertical-align: middle;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我的内容是引用的</p>
</blockquote>
<p><del>删除线</del></p>
<p>上标: x~2~</p>
<p>下标: o^2^</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
